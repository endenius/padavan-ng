--- tor-0.4.8.18.orig/src/app/config/config.c
+++ tor-0.4.8.18/src/app/config/config.c
@@ -3870,7 +3870,7 @@
       !options->HashedControlPassword &&
       !options->HashedControlSessionPassword &&
       !options->CookieAuthentication) {
-    log_warn(LD_CONFIG, "Control%s is %s, but no authentication method "
+    log_info(LD_CONFIG, "Control%s is %s, but no authentication method "
              "has been configured.  This means that any program on your "
              "computer can reconfigure your Tor.  That's bad!  You should "
              "upgrade your Tor controller as soon as possible.",
@@ -3879,7 +3879,7 @@
   }
 
   if (options->CookieAuthFileGroupReadable && !options->CookieAuthFile) {
-    log_warn(LD_CONFIG, "CookieAuthFileGroupReadable is set, but will have "
+    log_info(LD_CONFIG, "CookieAuthFileGroupReadable is set, but will have "
              "no effect: you must specify an explicit CookieAuthFile to "
              "have it group-readable.");
   }
@@ -5898,13 +5898,13 @@
     if (port->is_unix_addr) {
       /* Unix sockets aren't accessible over a network. */
     } else if (!tor_addr_is_internal(&port->addr, 1)) {
-      log_warn(LD_CONFIG, "You specified a public address '%s' for %sPort. "
+      log_info(LD_CONFIG, "You specified a public address '%s' for %sPort. "
                "Other people on the Internet might find your computer and "
                "use it as an open proxy. Please don't allow this unless you "
                "have a good reason.",
                fmt_addrport(&port->addr, port->port), portname);
     } else if (!tor_addr_is_loopback(&port->addr)) {
-      log_notice(LD_CONFIG, "You configured a non-loopback address '%s' "
+      log_info(LD_CONFIG, "You configured a non-loopback address '%s' "
                  "for %sPort. This allows everybody on your local network to "
                  "use your machine as a proxy. Make sure this is what you "
                  "wanted.",
--- tor-0.4.8.18.orig/src/app/main/main.c
+++ tor-0.4.8.18/src/app/main/main.c
@@ -588,7 +588,7 @@
                  tor_libc_get_name() : "Unknown",
                tor_libc_get_version_str());
 
-    log_notice(LD_GENERAL, "Tor can't help you if you use it wrong! "
+    log_info(LD_GENERAL, "Tor can't help you if you use it wrong! "
                "Learn how to be safe at "
                "https://support.torproject.org/faq/staying-anonymous/");
 
@@ -637,7 +637,7 @@
 
 #ifndef _WIN32
   if (geteuid()==0)
-    log_warn(LD_GENERAL,"You are running Tor as root. You don't need to, "
+    log_info(LD_GENERAL,"You are running Tor as root. You don't need to, "
              "and you probably shouldn't.");
 #endif
 
--- tor-0.4.8.18.orig/src/core/mainloop/connection.c
+++ tor-0.4.8.18/src/core/mainloop/connection.c
@@ -2055,7 +2055,7 @@
       log_info(LD_NET, "New SOCKS AF_UNIX connection opened");
     }
     if (new_type == CONN_TYPE_CONTROL) {
-      log_notice(LD_CONTROL, "New control connection opened from %s.",
+      log_info(LD_CONTROL, "New control connection opened from %s.",
                  fmt_and_decorate_addr(&addr));
     }
     if (new_type == CONN_TYPE_METRICS) {
@@ -2066,7 +2066,7 @@
   } else if (conn->socket_family == AF_UNIX && conn->type != CONN_TYPE_AP) {
     tor_assert(conn->type == CONN_TYPE_CONTROL_LISTENER);
     tor_assert(new_type == CONN_TYPE_CONTROL);
-    log_notice(LD_CONTROL, "New control connection opened.");
+    log_info(LD_CONTROL, "New control connection opened.");
 
     newconn = connection_new(new_type, conn->socket_family);
     newconn->s = news;
--- tor-0.4.8.18.orig/src/core/mainloop/mainloop.c
+++ tor-0.4.8.18/src/core/mainloop/mainloop.c
@@ -1137,7 +1137,7 @@
   if (!router_have_minimum_dir_info()) {
     int quiet = suppress_logs || from_cache ||
                 dirclient_too_idle_to_fetch_descriptors(options, now);
-    tor_log(quiet ? LOG_INFO : LOG_NOTICE, LD_DIR,
+    tor_log(LOG_INFO, LD_DIR,
         "I learned some more directory information, but not enough to "
         "build a circuit: %s", get_dir_info_status_string());
     update_all_descriptor_downloads(now);
--- tor-0.4.8.18.orig/src/core/or/circuitstats.c
+++ tor-0.4.8.18/src/core/or/circuitstats.c
@@ -1609,7 +1609,7 @@
 
   cbt_control_event_buildtimeout_set(cbt, BUILDTIMEOUT_SET_EVENT_RESET);
 
-  log_notice(LD_CIRC,
+  log_info(LD_CIRC,
             "Your network connection speed appears to have changed. Resetting "
             "timeout to %ldms after %d timeouts and %d buildtimes.",
             tor_lround(cbt->timeout_ms), timeout_count, total_build_times);
--- tor-0.4.8.18.orig/src/core/or/circuituse.c
+++ tor-0.4.8.18/src/core/or/circuituse.c
@@ -2301,7 +2301,7 @@
      * multihop circuits.
      */
     if (!connection_get_by_type(CONN_TYPE_DIR)) {
-      int severity = LOG_NOTICE;
+      int severity = LOG_INFO;
       /* Retry some stuff that might help the connection work. */
       /* If we are configured with EntryNodes or UseBridges */
       if (entry_list_is_constrained(options)) {
@@ -2404,7 +2404,7 @@
       static ratelim_t delay_limit = RATELIM_INIT(10*60);
       char *m;
       if ((m = rate_limit_log(&delay_limit, approx_time()))) {
-        log_notice(LD_APP, "We'd like to launch a circuit to handle a "
+        log_info(LD_APP, "We'd like to launch a circuit to handle a "
                    "connection, but we already have %d general-purpose client "
                    "circuits pending. Waiting until some finish.%s",
                    n_pending, m);
--- tor-0.4.8.18.orig/src/core/or/connection_edge.c
+++ tor-0.4.8.18/src/core/or/connection_edge.c
@@ -1201,7 +1201,7 @@
     conn = ENTRY_TO_EDGE_CONN(entry_conn);
     /* if it's an internal linked connection, don't yell its status. */
     severity = (tor_addr_is_null(&base_conn->addr) && !base_conn->port)
-      ? LOG_INFO : LOG_NOTICE;
+      ? LOG_INFO : LOG_INFO;
     seconds_idle = (int)( now - base_conn->timestamp_last_read_allowed );
     seconds_since_born = (int)( now - base_conn->timestamp_created );
 
--- tor-0.4.8.18.orig/src/core/or/relay.c
+++ tor-0.4.8.18/src/core/or/relay.c
@@ -1030,7 +1030,7 @@
             return 0;
           /* else, conn will get closed below */
         } else {
-          log_notice(LD_APP,
+          log_info(LD_APP,
                      "Have tried resolving or connecting to address '%s' "
                      "at %d different places. Giving up.",
                      safe_str(conn->socks_request->address),
--- tor-0.4.8.18.orig/src/feature/client/bridges.c
+++ tor-0.4.8.18/src/feature/client/bridges.c
@@ -907,7 +907,7 @@
     if (!tor_addr_is_null(&ri->ipv6_addr)) {
       tor_addr_port_t ap;
       node_get_pref_orport(node, &ap);
-      log_notice(LD_CONFIG,
+      log_info(LD_CONFIG,
                  "Bridge '%s' has both an IPv4 and an IPv6 address.  "
                  "Will prefer using its %s address (%s) based on %s.",
                  ri->nickname,
@@ -964,7 +964,7 @@
     if (!tor_addr_is_null(&rs->ipv6_addr)) {
       tor_addr_port_t ap;
       node_get_pref_orport(node, &ap);
-      log_notice(LD_CONFIG,
+      log_info(LD_CONFIG,
                  "Bridge '%s' has both an IPv4 and an IPv6 address.  "
                  "Will prefer using its %s address (%s) based on %s.",
                  rs->nickname,
@@ -1019,7 +1019,7 @@
       rewrite_node_address_for_bridge(bridge, node);
       if (tor_digest_is_zero(bridge->identity)) {
         memcpy(bridge->identity,ri->cache_info.identity_digest, DIGEST_LEN);
-        log_notice(LD_DIR, "Learned identity %s for bridge at %s:%d",
+        log_info(LD_DIR, "Learned identity %s for bridge at %s:%d",
                    hex_str(bridge->identity, DIGEST_LEN),
                    fmt_and_decorate_addr(&bridge->addr),
                    (int) bridge->port);
@@ -1028,7 +1028,7 @@
                               (const uint8_t*)ri->cache_info.identity_digest);
 
       if (desc_is_new)
-        log_notice(LD_DIR, "new bridge descriptor '%s' (%s): %s",
+        log_info(LD_DIR, "new bridge descriptor '%s' (%s): %s",
                    ri->nickname,
                    from_cache ? "cached" : "fresh", router_describe(ri));
       /* If we didn't have a reachable bridge before this one, try directory
--- tor-0.4.8.18.orig/src/feature/client/entrynodes.c
+++ tor-0.4.8.18/src/feature/client/entrynodes.c
@@ -2167,7 +2167,7 @@
            * anyway and log. */
           if (smartlist_len(usable_primary_guards) == 0) {
             static ratelim_t guardlog = RATELIM_INIT(60);
-            log_fn_ratelim(&guardlog, LOG_NOTICE, LD_GUARD,
+            log_fn_ratelim(&guardlog, LOG_INFO, LD_GUARD,
                            "All current guards excluded by path restriction "
                            "type %d; using an additonal guard.",
                            rst->type);
--- tor-0.4.8.18.orig/src/feature/dirclient/dirclient.c
+++ tor-0.4.8.18/src/feature/dirclient/dirclient.c
@@ -500,7 +500,7 @@
         if (guard_state) {
           entry_guard_cancel(&guard_state);
         }
-        log_notice(LD_DIR, "Ignoring directory request, since no bridge "
+        log_info(LD_DIR, "Ignoring directory request, since no bridge "
                            "nodes are available yet.");
       }
 
@@ -1996,7 +1996,7 @@
 
     if (smartlist_len(lines) > 0) {
       char *log_line = smartlist_join_strings(lines, "; ", 0, NULL);
-      log_notice(LD_NET, "While %sbootstrapping, fetched this many bytes: %s",
+      log_info(LD_NET, "While %sbootstrapping, fetched this many bytes: %s",
                  bootstrapped?"not ":"", log_line);
       tor_free(log_line);
 
--- tor-0.4.8.18.orig/src/feature/hs/hs_client.c
+++ tor-0.4.8.18/src/feature/hs/hs_client.c
@@ -305,7 +305,7 @@
   if (count > 0) {
     char onion_address[HS_SERVICE_ADDR_LEN_BASE32 + 1];
     hs_build_address(identity_pk, HS_VERSION_THREE, onion_address);
-    log_notice(LD_REND, "Closed %u streams for service %s.onion "
+    log_info(LD_REND, "Closed %u streams for service %s.onion "
                         "for reason %s. Fetch status: %s.",
                count, safe_str_client(onion_address),
                stream_end_reason_to_string(reason),
--- tor-0.4.8.18.orig/src/feature/nodelist/nodelist.c
+++ tor-0.4.8.18/src/feature/nodelist/nodelist.c
@@ -2645,7 +2645,7 @@
 
   if (old_have_consensus_path != have_consensus_path) {
     if (have_consensus_path == CONSENSUS_PATH_INTERNAL) {
-      log_notice(LD_NET,
+      log_info(LD_NET,
                  "The current consensus has no exit nodes. "
                  "Tor can only build internal paths, "
                  "such as paths to onion services.");
@@ -2655,7 +2655,7 @@
        * the network to build exit paths, such as paths for world wide web
        * browsing (as distinct from hidden service web browsing). */
     } else if (old_have_consensus_path == CONSENSUS_PATH_INTERNAL) {
-      log_notice(LD_NET,
+      log_info(LD_NET,
                  "The current consensus contains exit nodes. "
                  "Tor can build exit and internal paths.");
     }
@@ -2885,7 +2885,7 @@
   if (res && !have_min_dir_info) {
     control_event_client_status(LOG_NOTICE, "ENOUGH_DIR_INFO");
     control_event_boot_dir(BOOTSTRAP_STATUS_ENOUGH_DIRINFO, 0);
-    tor_log(be_loud_when_things_work_again ? LOG_NOTICE : LOG_INFO, LD_DIR,
+    tor_log(LOG_INFO, LD_DIR,
             "We now have enough directory information to build circuits.");
     be_loud_when_things_work_again = 0;
   }
@@ -2893,7 +2893,7 @@
   /* If paths have just become unavailable in this update. */
   if (!res && have_min_dir_info) {
     int quiet = dirclient_too_idle_to_fetch_descriptors(options, now);
-    tor_log(quiet ? LOG_INFO : LOG_NOTICE, LD_DIR,
+    tor_log(LOG_INFO, LD_DIR,
         "Our directory information is no longer up-to-date "
         "enough to build circuits: %s", dir_info_status);
     if (!quiet) {
